const express = require("express");
const router = express.Router();
const sql = require("mssql");
const { poolPromise } = require("../db/alarmsdb");
const PDFDocument = require("pdfkit");
const fs = require("fs");
const path = require("path");

router.post("/reports/generate", async (req, res) => {
  const { startDate, endDate, username } = req.body;

  try {
    const pool = await poolPromise;
    const result = await pool.request()
      .input("start", sql.DateTime, new Date(startDate))
      .input("end", sql.DateTime, new Date(endDate))
      .query(`SELECT * FROM AllEvent WHERE EventTimeStamp BETWEEN @start AND @end`);

    const data = result.recordset;
    if (!data || data.length === 0) {
      return res.status(404).json({ message: "No data found for selected dates" });
    }

    const displayColumns = [
      "SourceName",
      "ServerName",
      "EventTimeStamp",
      "Severity",
      "Priority",
      "Message",
      "ConditionName"
    ];

    const columnWidths = {
      SourceName: 80,
      ServerName: 80,
      EventTimeStamp: 110,
      Severity: 50,
      Priority: 50,
      Message: 130,
      ConditionName: 80,
    };

    const doc = new PDFDocument({ size: "A4", margin: 30, bufferPages: true });
    const filePath = path.join(__dirname, "../reports/generated", `report_${Date.now()}.pdf`);
    const stream = fs.createWriteStream(filePath);
    doc.pipe(stream);

    doc.fontSize(18).text("All Event Report", { align: "center" }).moveDown(1);

    const pageWidth = doc.page.width;
    const tableWidth = Object.values(columnWidths).reduce((a, b) => a + b, 0);
    const startX = (pageWidth - tableWidth) / 2;
    let y = doc.y;
    const footerHeight = 40;
    const bottomMargin = 40;

    const drawFooter = () => {
      const watermark = `Generated by ${username} on ${new Date().toLocaleString()}`;
      doc.fontSize(8).fillColor("gray")
        .text(watermark, 30, doc.page.height - footerHeight, { align: "center" });
    };

    const drawRow = (row, isHeader = false, rowIndex = 0) => {
      let x = startX;
      const heights = [];

      // Measure height of each cell content
      displayColumns.forEach(col => {
        const text = isHeader ? col : String(row[col] ?? "");
        doc.font(isHeader ? "Helvetica-Bold" : "Helvetica").fontSize(isHeader ? 9 : 8);
        const height = doc.heightOfString(text, {
          width: columnWidths[col] - 10,
          align: "center"
        });
        heights.push(height);
      });

      const rowHeight = Math.max(...heights) + 4;

      // Before overflowing page, draw footer and add a page
      if (y + rowHeight > doc.page.height - bottomMargin) {
        drawFooter();
        doc.addPage();
        y = doc.y;
      }

      // Alternating row background
      if (!isHeader && rowIndex % 2 === 1) {
        doc.rect(startX, y, tableWidth, rowHeight).fillAndStroke("#f2f2f2", "#000").fill("#000");
      }

      x = startX;
      displayColumns.forEach((col, colIndex) => {
        const text = isHeader ? col : String(row[col] ?? "");
        const cellWidth = columnWidths[col];
        const textHeight = heights[colIndex];
        const textY = y + (rowHeight - textHeight) / 2;

        doc.rect(x, y, cellWidth, rowHeight).stroke();
        doc.fillColor("#000")
          .font(isHeader ? "Helvetica-Bold" : "Helvetica")
          .fontSize(isHeader ? 9 : 8)
          .text(text, x + 5, textY, {
            width: cellWidth - 10,
            align: "center"
          });
        x += cellWidth;
      });

      y += rowHeight;
    };

    drawRow({}, true); // header
    data.forEach((row, idx) => {
      drawRow(row, false, idx);
    });

    drawFooter(); // Final page footer

    doc.end();
    stream.on("finish", () => {
      res.status(200).json({ message: "PDF report generated successfully" });
    });

  } catch (err) {
    console.error("PDF generation error:", err);
    res.status(500).json({ message: "Failed to generate report" });
  }
});

module.exports = router;
