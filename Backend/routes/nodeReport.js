const express = require("express");
const router = express.Router();
const sql = require("mssql");
const { poolPromise } = require("../db/alarmsdb");
const PDFDocument = require("pdfkit");
const fs = require("fs");
const path = require("path");

// 1️⃣ Preview data route
router.get("/reports/preview", async (req, res) => {
  const { start_date, end_date } = req.query;

  try {
    const pool = await poolPromise;
    const result = await pool.request()
      .input("start", sql.DateTime, new Date(start_date))
      .input("end", sql.DateTime, new Date(end_date))
      .query(`SELECT * FROM AllEvent WHERE EventTimeStamp BETWEEN @start AND @end`);

    res.json(result.recordset);
  } catch (err) {
    console.error("Preview fetch error:", err);
    res.status(500).json({ message: "Failed to fetch preview data" });
  }
});

// 2️⃣ Generate PDF report
router.post("/reports/generate", async (req, res) => {
  const { startDate, endDate, username } = req.body;

  try {
    const pool = await poolPromise;
    const result = await pool.request()
      .input("start", sql.DateTime, new Date(startDate))
      .input("end", sql.DateTime, new Date(endDate))
      .query(`SELECT * FROM AllEvent WHERE EventTimeStamp BETWEEN @start AND @end`);

    const data = result.recordset;
    if (!data || data.length === 0) {
      return res.status(404).json({ message: "No data found for selected dates" });
    }

    // ✅ PDF Generation with bufferPages
    const doc = new PDFDocument({ margin: 30, size: "A4", bufferPages: true });
    const filePath = path.join(__dirname, "../reports/generated", `report_${Date.now()}.pdf`);
    const stream = fs.createWriteStream(filePath);
    doc.pipe(stream);

    // Title
    doc.fontSize(18).text("All Event Report", { align: "center" });
    doc.moveDown();

    // Table headers
    const headers = Object.keys(data[0]);
    doc.fontSize(10);
    headers.forEach(header => {
      doc.text(header, { continued: true, underline: true }).text("   ");
    });
    doc.moveDown(0.5);

    // Table rows
    data.forEach(row => {
      headers.forEach(header => {
        doc.text(String(row[header]), { continued: true }).text("   ");
      });
      doc.moveDown(0.5);
    });

    // ✅ Footer watermark with safe switching
    const timestamp = new Date().toLocaleString();
    const watermark = `Generated by ${username} on ${timestamp}`;

    const range = doc.bufferedPageRange(); // { start: 0, count: X }
    for (let i = range.start; i < range.start + range.count; i++) {
      doc.switchToPage(i);
      doc.fontSize(8).fillColor('gray')
        .text(watermark, 30, doc.page.height - 30, { align: 'center' });
    }

    doc.end();

    stream.on("finish", () => {
      res.status(200).json({ message: "Report generated successfully" });
    });

  } catch (err) {
    console.error("PDF generation error:", err);
    res.status(500).json({ message: "Failed to generate report" });
  }
});

module.exports = router;
