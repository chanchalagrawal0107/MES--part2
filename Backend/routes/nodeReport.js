const express = require("express");
const router = express.Router();
const sql = require("mssql");
const { poolPromise: alarmsPool } = require("../db/alarmsdb");
const { poolPromise: assetCentrePool } = require("../db/assetcentre_db");
const PDFDocument = require("pdfkit");
const fs = require("fs");
const path = require("path");

// 1️⃣ Preview data route
router.get("/reports/preview", async (req, res) => {
  const { start_date, end_date, source } = req.query;

  if (!start_date || !end_date || !source) {
    return res.status(400).json({ message: "Missing parameters" });
  }

  try {
    const pool = source === "assetcentre" ? await assetCentrePool : await alarmsPool;

    const tableName = source === "assetcentre" ? "log_AuditEventLog" : "AllEvent";
    const dateColumn = source === "assetcentre" ? "DateTimeOccurred" : "EventTimeStamp";

    const result = await pool.request()
      .input("start", sql.DateTime, new Date(start_date))
      .input("end", sql.DateTime, new Date(end_date))
      .query(`SELECT * FROM ${tableName} WHERE ${dateColumn} BETWEEN @start AND @end`);

    res.json(result.recordset);
  } catch (err) {
    console.error("Preview fetch error:", err);
    res.status(500).json({ message: "Failed to fetch preview data" });
  }
});

// 2️⃣ Generate PDF report
router.post("/reports/generate", async (req, res) => {
  const { startDate, endDate, username, source } = req.body;
  console.log("📥 Request received:", req.body);

  if (!startDate || !endDate || !username || !source) {
    return res.status(400).json({ message: "Missing parameters" });
  }

  try {
    const pool = source === "assetcentre" ? await assetCentrePool : await alarmsPool;

    const tableName = source === "assetcentre" ? "log_AuditEventLog" : "AllEvent";
    const dateColumn = source === "assetcentre" ? "DateTimeOccurred" : "EventTimeStamp";
    const folderName = source === "assetcentre" ? "assetcentre" : "alarms";
    const reportTitle = source === "assetcentre" ? "Asset Centre Audit Report" : "All Event Report";

    const result = await pool.request()
      .input("start", sql.DateTime, new Date(startDate))
      .input("end", sql.DateTime, new Date(endDate))
      .query(`SELECT * FROM ${tableName} WHERE ${dateColumn} BETWEEN @start AND @end`);

    const data = result.recordset;
    if (!data.length) {
      return res.status(404).json({ message: "No data found" });
    }

    // PDF Generation
    const doc = new PDFDocument({ margin: 30, size: "A4", bufferPages: true });
    const dirPath = path.join(__dirname, `../reports/generated`);
    fs.mkdirSync(dirPath, { recursive: true });
    const filePath = path.join(dirPath, `${folderName}_report_${Date.now()}.pdf`);
    const stream = fs.createWriteStream(filePath);
    doc.pipe(stream);

    doc.fontSize(18).text(reportTitle, { align: "center" }).moveDown();
    const headers = Object.keys(data[0]);

    doc.fontSize(10);
    headers.forEach(header => {
      doc.text(header, { continued: true, underline: true }).text("   ");
    });
    doc.moveDown(0.5);

    data.forEach(row => {
      headers.forEach(header => {
        doc.text(String(row[header]), { continued: true }).text("   ");
      });
      doc.moveDown(0.5);
    });

    // Footer Watermark
    const timestamp = new Date().toLocaleString();
    const watermark = `Generated by ${username} on ${timestamp}`;
    const range = doc.bufferedPageRange();
    for (let i = range.start; i < range.start + range.count; i++) {
      doc.switchToPage(i);
      doc.fontSize(8).fillColor("gray").text(watermark, 30, doc.page.height - 30, { align: "center" });
    }

    doc.end();
    stream.on("finish", () => {
      res.status(200).json({ message: `${source} report generated successfully` });
    });

  } catch (err) {
    console.error("PDF generation error:", err);
    res.status(500).json({ message: "Failed to generate report" });
  }
});

module.exports = router;
