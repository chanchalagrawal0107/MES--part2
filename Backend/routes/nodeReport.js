const express = require("express");
const router = express.Router();
const sql = require("mssql");
const { poolPromise: alarmsPool } = require("../db/alarmsdb");
const { poolPromise: assetCentrePool } = require("../db/assetcentre_db");
const PDFDocument = require("pdfkit");
const fs = require("fs");
const path = require("path");

// 1ï¸âƒ£ Preview data route
router.get("/reports/preview", async (req, res) => {
  const { start_date, end_date, source } = req.query;

  if (!start_date || !end_date || !source) {
    return res.status(400).json({ message: "Missing parameters" });
  }

  try {
    const pool = source === "assetcentre" ? await assetCentrePool : await alarmsPool;
    const tableName = source === "assetcentre" ? "log_AuditEventLog" : "AllEvent";
    const dateColumn = source === "assetcentre" ? "DateTimeOccurred" : "EventTimeStamp";

    const result = await pool.request()
      .input("start", sql.DateTime, new Date(start_date))
      .input("end", sql.DateTime, new Date(end_date))
      .query(`SELECT * FROM ${tableName} WHERE ${dateColumn} BETWEEN @start AND @end`);

    res.json(result.recordset);
  } catch (err) {
    console.error("Preview fetch error:", err);
    res.status(500).json({ message: "Failed to fetch preview data" });
  }
});

// 2ï¸âƒ£ Generate PDF report
router.post("/reports/generate", async (req, res) => {
  const { startDate, endDate, username, source } = req.body;
  console.log("ðŸ“¥ Request received:", req.body);

  if (!startDate || !endDate || !username || !source) {
    return res.status(400).json({ message: "Missing parameters" });
  }

  try {
    const pool = source === "assetcentre" ? await assetCentrePool : await alarmsPool;

    const tableName = source === "assetcentre" ? "log_AuditEventLog" : "AllEvent";
    const dateColumn = source === "assetcentre" ? "DateTimeOccurred" : "EventTimeStamp";
    // const folderName = source === "assetcentre" ? "assetcentre" : "alarms";
    let reportTitle = source === "assetcentre" ? "Asset Centre Audit Report" : "All Event Report";

    const result = await pool.request()
      .input("start", sql.DateTime, new Date(startDate))
      .input("end", sql.DateTime, new Date(endDate))
      .query(`SELECT * FROM ${tableName} WHERE ${dateColumn} BETWEEN @start AND @end`);

    const data = result.recordset;
    if (!data.length) {
      return res.status(404).json({ message: "No data found" });
    }

    let displayColumns, columnWidths;

if (source === "assetcentre") {
  displayColumns = [
    "RecordID",
    "DateTimeOccurred",
    "EventSource",
    "Location",
    "Resource",
    "UserName",
    "Message",
    "DateTimeLogged",
    "AttachmentCount"
  ];

  columnWidths = {
    RecordID: 110,
    DateTimeOccurred: 100,
    EventSource: 100,
    Location: 70,
    Resource: 70,
    UserName: 90,
    Message: 150,
    DateTimeLogged: 100,
    AttachmentCount: 60
  };

  reportTitle = "Asset Centre Audit Report";

} else {
  displayColumns = [
    "SourceName",
    "ServerName",
    "EventTimeStamp",
    "Severity",
    "Priority",
    "Message",
    "ConditionName"
  ];

  columnWidths = {
    SourceName: 80,
    ServerName: 80,
    EventTimeStamp: 120,
    Severity: 50,
    Priority: 50,
    Message: 140,
    ConditionName: 80
  };

  reportTitle = "All Event Report";
}


const doc = new PDFDocument({ size: "A4",layout:"landscape", margin: 30, bufferPages: true });
const dirPath = path.join(__dirname, `../reports/generated`);
fs.mkdirSync(dirPath, { recursive: true });

let timestamp = new Date();
const filename = `${source}_report_${timestamp.toISOString().split("T")[0]}_${timestamp.getHours()}${timestamp.getMinutes()}.pdf`;
const filePath = path.join(dirPath, filename);
const stream = fs.createWriteStream(filePath);
doc.pipe(stream);

doc.fontSize(18).text(reportTitle, { align: "center" }).moveDown(1);

const pageWidth = doc.page.width;
const tableWidth = Object.values(columnWidths).reduce((a, b) => a + b, 0);
const startX = (pageWidth - tableWidth) / 2;
let y = doc.y;
const footerHeight = 40;
const bottomMargin = 70;

const drawFooter = () => {
  const watermark = `Generated by ${username} on ${new Date().toLocaleString()}`;
  doc.fontSize(8).fillColor("gray")
     .text(watermark, 30, doc.page.height - 50, { align: "left" });
};

const drawRow = (row, isHeader = false, rowIndex = 0) => {
  let x = startX;
  const heights = [];

  displayColumns.forEach(col => {
    const text = isHeader ? col : String(row[col] ?? "");
    doc.font(isHeader ? "Helvetica-Bold" : "Helvetica").fontSize(isHeader ? 9 : 8);
    const height = doc.heightOfString(text, {
      width: columnWidths[col] - 10,
      align: "center"
    });
    heights.push(height);
  });

  const rowHeight = Math.max(...heights) + 4;

  if (y + rowHeight > doc.page.height - bottomMargin) {
    drawFooter();
    doc.addPage();
    y = doc.y;
  }

  if (!isHeader && rowIndex % 2 === 1) {
    doc.rect(startX, y, tableWidth, rowHeight).fillAndStroke("#f9f9f9", "#000").fill("#000");
  }

  x = startX;
  displayColumns.forEach((col, colIndex) => {
    const text = isHeader ? col : String(row[col] ?? "");
    const cellWidth = columnWidths[col];
    const textHeight = heights[colIndex];
    const textY = y + (rowHeight - textHeight) / 2;

    doc.rect(x, y, cellWidth, rowHeight).stroke();
    doc.fillColor("#000")
      .font(isHeader ? "Helvetica-Bold" : "Helvetica")
      .fontSize(isHeader ? 9 : 8)
      .text(text, x + 5, textY, {
        width: cellWidth - 10,
        align: "center"
      });
    x += cellWidth;
  });

  y += rowHeight;
};

drawRow({}, true); // Header
data.forEach((row, idx) => drawRow(row, false, idx));
drawFooter();

doc.end();
stream.on("finish", () => {
  res.status(200).json({ message: `${source} report generated successfully` });
});


  } catch (err) {
    console.error("PDF generation error:", err);
    res.status(500).json({ message: "Failed to generate report" });
  }
});

module.exports = router;
